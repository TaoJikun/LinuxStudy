[TOC]



# 9.1 引言





# 9.2 终端登录





# 9.3 网络登录





# 9.4 进程组

每个进程除了有一个进程ID之外，还属于一个进程组。

进程组是一个或多个进程的集合。通常，它们是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID，它是一个正整数，并可存放在pid_t数据类型中。

函数`getpgrp`返回调用进程的进程组ID.
```C++
#include <unistd.h>

pid_t getpgrp(void);
//返回值：调用进程的进程组。
```

每个进程组有一个组长进程。组长进程的进程组D等于其进程ID。

进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。

进程调用`setpgid`函数可以加入一个现有的进程组或者创建一个新进程组。
```C++
#include <unistd.h>

pid_t setpgid(pid_t pid, pid_t pgid);
//返回值：若成功，返回0；若出错，返回-1。
```
setpgid函数将pid进程的进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。如果pid是0，则使用调用者的进程ID。另外，如果pgid是0，则由pid指定的进程ID用作进程组ID。

一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后，它就不再更改该子进程的进程组ID。

在大多数作业控制shell中，在fork之后调用此函数。使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID。这两个调用中有一个是冗余的，但让父进程和子进程都这样做可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如果不这样做，在fork之后，由于父进程和子进程运行的先后次序不确定。会因为子进程的组员身份取决于哪个进程首先执行而产生竞争条件。



# 9.5 会话





# 9.6 控制终端





# 9.7 函数 tcgetpgrp、tcsetpgrp 和 tcgetsid





# 9.8 作业控制





# 9.9 shell执行程序





# 9.10 孤儿进程组

一个其父进程已经终止的进程称为孤儿进程，这种进程由init进程收养。同样的，进程组也可以成为孤儿进程组。

POSIX.1将孤儿进程组定义为：该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。对孤儿进程组的另一种描述可以是：一个进程组不是孤儿进程组的条件是该组中有一个进程，其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组，那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。



# 9.11 FreeBSD实现