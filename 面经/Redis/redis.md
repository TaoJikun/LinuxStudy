[toc]


# 一、面试篇


## 1、Redis常见面试题

### 认识Redis

#### 什么是Redis？

Redis是一种**基于内存**的数据库，对数据的读写操作都是在内存中完成的，因此**读写速度都非常快**，常用于**缓存、消息队列、分布式锁**等场景。

Redis提供的数据类型：**String(字符串)、Hash(哈希)、List(列表)、Set(集合)、ZSet(有序集合)**、Bitmaps(位图)、HyperLogLog(基数统计)、GEO(地理信息)、Stream(流)。

Redis对数据类型的操作都是**原子性**的，因为执行的命令由**单线程**负责，不存在并发问题。

Redis还支持**事务 、持久化、Lua脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式、内存淘汰机制、过期删除机制**等等。


#### Redis和Memcached有什么区别？

共同点：
* 都是基于内存的数据库，一般都用来当作缓存使用。
* 都有过期策略。
* 两者性能都非常高。

不同点：
* Redis支持的数据类型更加丰富（String、Hash、List、Set、ZSet）；而Memcached只支持最简单的key-value类型。
* Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；Memcached没有持久化功能，数据全部存在内存之中，Memcached重启或者挂掉后，数据就没了。
* Redis原生支持集群模式；Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
* Redis支持发布订阅模型、Lua脚本、事务等功能；Memcached不支持。


#### 为什么用Redis作为MySQL的缓存？

1. Redis具备**高性能**。
    用户第一次访问MySQL中的数据时需要从磁盘上读取，比较低效。将MySQL中的数据缓存到Redis中，**下次再访问这些数据的时候就可以直接从Redis缓存中获取，相当于直接操作内存，速度相对较快**。
2. Redis具备**高并发**。
    单台设备的Redis的QPS（Query Per Second，每秒钟处理完请求的次数）是MySQL的10倍，Redis单机的QPS能轻松破10w，而MySQL单机的QPS很难破1w。所以，**直接访问Redis能够承受的请求是远远大于直接访问MySQL的**，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。



### Redis数据结构

#### Redis数据类型以及使用场景

Redis中最常见的五种数据类型：**String(字符串)、Hash(哈希)、List(列表)、Set(集合)、ZSet(有序集合)**。

![Redis常用数据类型](./picture/Redis常用数据类型.bmp)

![Redis五种数据类型对比](./picture/Redis五种数据类型对比.bmp)


Redis这五种数据类型的应用场景：
- String类型应用场景：缓存对象、常规计数、分布式锁、共享session信息等。
- List类型应用场景：消息队列（但是有两个问题：1、生产者需要自行实现全局唯一ID；2、不能以消费组形式消费数据）等。
- Hash类型应用场景：缓存对象、购物车等。
- Set类型应用场景：聚合计算（交集、并集、差集）场景，比如点赞、共同关注、抽奖活动等。
- ZSet类型应用场景：排序场景，比如排行榜、电话和姓名排序等。

随着Redis版本的更新，后面又支持了四种数据类型：BitMap（2.2版新增）、HyperLogLog（2.8版新增）、GEO（3.2版新增）、Stream（5.0版新增）。
- Bitmaps类型应用场景：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等。
- HyperLogLog类型应用场景：海量数据基数统计的场景，比如百万级网页UV计数等。
- GEO类型应用场景：存储地理位置信息的场景，比如滴滴叫车。
- Stream类型应用场景：消息队列，相比于基于List类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。


#### 五种常见的Redis数据类型的实现

![Redis数据类型的底层数据结构](./picture/Redis数据类型的底层数据结构.bmp)

##### 1、String类型的内部实现

String类型的底层的数据结构实现主要是**SDS**（Simple Dynamic String，简单动态字符串）。
```C++
struct sdshdr{
    //记录buf数组中已使用字节的数量
    //等于SDS所保存字符串的长度（不包括结尾的'\0'），未使用的部分不包括在其中
    int len;

    //记录buf数组中未使用的字节的数量
    int free;

    //字节数组，用于保存字符串
    char buf[];
};
```

**SDS相较于C字符串的优点**：
* **SDS获取字符串长度的时间复杂度是O(1)**。因为C语言的字符串并不记录自身长度，所以获取长度的复杂度为O(n)；而SDS结构里用len属性记录了字符串长度，所以复杂度为O(1)。
* **SDS不仅可以保存文本数据，还可以保存二进制数据**。因为SDS使用len属性的值而不是空字符来判断字符串是否结束，并且SDS的所有API都会以处理二进制的方式来处理SDS存放在buf[]数组里的数据。所以SDS不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
* **SDS API是安全的，拼接字符串不会造成缓冲区溢出**。因为SDS在拼接字符串之前会检查SDS空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。
* **SDS能够减少修改字符串时带来的内存重分配次数**。因为C语言的字符串不记录自身的长度，每一次增长或者缩短一个C字符串都会导致内存重分配操作，故修改字符串长度N次**必然**需要执行N次内存重分配；而**SDS采用空间预分配和惰性空间释放策略**，使得修改字符串长度N次**最多**需要执行N次内存重分配。

![C字符串和SDS之间的区别](./picture/C字符串和SDS之间的区别.bmp)


**SDS的空间预分配策略**：
* 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将**小于1MB**，那么**程序分配和len属性同样大小的未使用空间**，这时SDS len属性的值将和free属性的值相同。  
    例如：如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节，额外的一字节用于保存空字符。
* 如果对SDS进行修改之后，SDS的长度将**大于等于1MB**，那么程序会**分配1MB的未使用空间**。  
    如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB + 1MB + 1byte。


##### 2、List类型的内部实现

List类型的底层数据结构是由**双向链表或压缩列表**实现的。  

* 如果列表的元素个数小于512个（默认值，可由`list-max-ziplist-entries`配置），列表每个元素的值都小于64字节（默认值，可由`list-max-ziplist-value`配置），Redis会使用压缩列表作为List类型的底层数据结构；
* 如果列表的元素不满足上面的条件，Redis会使用双向链表作为List类型的底层数据结构。
> 但是在Redis 3.2版本之后，List数据类型底层数据结构就只由quicklist实现了，替代了双向链表和压缩列表。

```C++
//链表节点
typedef struct listNode{
    //前置节点
    struct listNode *prev;

    //后置节点
    struct listNode *next;

    //节点的值
    void *value;
}listNode;


//链表
typedef struct list{
    //表头节点
    struct listNode *head;

    //表尾节点
    struct listNode *tail;

    //链表所包含的节点数量
    unsigned long len;
    
    //节点值赋值函数
    void *(*dup) (void *ptr);

    //节点值释放函数
    void *(*free) (void *ptr);

    //节点值对比函数
    int (*match) (void *ptr, void *key);
}list;
```


##### 3、Hash类型的内部实现

Hash类型的底层数据结构是由**压缩列表或哈希表**实现的。

* 如果哈希类型元素个数小于512个（默认值，可由`hash-max-ziplist-entries`配置），所有值小于64字节（默认值，可由`hash-max-ziplist-value`配置）的话，Redis会使用压缩列表作为Hash类型的底层数据结构；
* 如果哈希类型元素不满足上面条件，Redis会使用哈希表作为Hash类型的底层数据结构。
> 在Redis 7.0中，压缩列表数据结构已经废弃了，交由listpack数据结构来实现了。


##### 4、Set类型的内部实现

Set类型的底层数据结构是由**哈希表或整数集合**实现的。

* 如果集合中的元素都是整数且元素个数小于512（默认值，`set-maxintset-entries`配置）个，Redis会使用整数集合作为Set类型的底层数据结构；
* 如果集合中的元素不满足上面条件，则Redis使用哈希表作为Set类型的底层数据结构。


##### 5、ZSet类型的内部实现

Zset类型的底层数据结构是由**压缩列表或跳表**实现的。

* 如果有序集合的元素个数小于128个，并且每个元素的值小于64字节时，Redis会使用压缩列表作为Zset类型的底层数据结构；
* 如果有序集合的元素不满足上面的条件，Redis会使用跳表作为Zset类型的底层数据结构。
> 在Redis 7.0中，压缩列表数据结构已经废弃了，交由listpack数据结构来实现了。
