[toc]

# 设计模式的六大原则

* 单一职责原则：一个类只负责一项职责。
* 开放封闭原则：对扩展开放，对修改封闭。
* 里氏替换原则：任何时候都可以用子类型替换父类型，子类一定是增加父类的能力而不是减少父类的能力。
* 接口隔离原则：使用多个隔离的接口（小而专），比使用单个接口（大而全）好，降低耦合性。
* 依赖倒置原则：高层模块不应该依赖于底层模块，两者应该依赖于底层的抽象；抽象不应该依赖具体实现，具体实现应该依赖抽象。
* 迪米特法则：最小知识原则，一个类对于其他类知道的越少越好。



# 创建型设计模式

用于构建对象，以便将他们可以从实现系统中分离出来。注重完成对象的实例化。


## 单例模式

背景：
在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。


定义：**保证一个类只有一个实例，并提供一个访问它的全局节点**。


在应用程序的整个生命周期中，对象只有一个实例的时候，就会使用单例模式。单例类总是在第一次访问时完成实例化，直至程序退出时都只是用同一个实例。


单一实例创建策略：通过将类的构造函数设置为private的来限制单例类的实例化。在定义类时包含一个该类的静态私有对象，以便创建单例类的实例。


* Singleton模式中的实例构造器可以设置为protected以允许子类派生。
* Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初中违背。
* 如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。



## 工厂方法模式

背景：
软件构建过程中经常面临对象创建工作，由于需求变化，创建的对象的具体类型经常变化。需要绕过常规的对象创建方法，提供一种封装机制来避免客户程序与创建工作的紧耦合。


定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类（在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型）。


* Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。
* Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。
* Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。


优点：
* 可以避免创建者和具体产品之间的紧密耦合
* 单一职责原则。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。
* 开闭原则。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。


缺点：需要引入许多新的子类，代码可能会因此变得更复杂。



## 抽象工厂模式

背景：
在软件系统中，经常面临着一系列相互依赖的对象工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。


定义：提供一个接口，让该接口负责创建一系列相关或者相互依赖的对象，无需指定它们具体的类。


* Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。
* Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。
* Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。



## 生成器模式

背景：
在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

定义：将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。


* Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。
* 变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。
* 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别。



## 原型模式

背景：
在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。


定义：使用原型实例指定创建对象的种类，然后通过拷贝（clone）这些原型来创建新的对象。


* Prototype模式同样用于隔离对象的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些“易变类”拥有稳定的接口。
* Prototype模式对于“如何创建易变类的实体对象“采用”原型克隆“的方法来做， 它使得我们可以非常灵活地动态创建”拥有某些稳定接口“的新对象——所需工作仅仅是注册一个新类的对象(即原型)， 然后在任何需要的地方Clone。
* Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。



# 结构型设计模式

用于指导我们完成对代码的结构划分，如此，代码结构会更加清晰，更易理解，也提高了软件的可维护性。


## 适配器模式

背景：
由于应用环境的变化，常常需要将”一些现存的对象“放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足。


定义：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。



## 外观模式

背景：
客户和组件中各种复杂的子系统有过多的耦合，需要简化外部客户程序和系统间的交互接口。


定义：为子系统中的一组接口提供一个一致(稳定)的界面，Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(复用)。


* 从客户程序角度来看，Façade模式简化了整个组件系统的接口，对于组件内部与外部的客户程序来说， 达到了一种”解耦“的效果——内部子系统的任何变化不会影响到Façade接口的变化。
* Façade设计模式更注重架构的层次去看整个系统，而不是单个类的层次。Façade很多时候是一种架构设计模式。
* Façade设计模式并非一个集装箱，可以任意地放进任何多个对象。Façade模式组件中的内部应该是”相互耦合关系比较大的一系列组件“，而不是一个简单的功能集合。



## 代理模式

背景：
在面向对象系统中，有些对象由于某种原因(比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等)， 直接访问会给使用者、或者系统结构带来很多麻烦。那么就要在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性，增加一层间接层是软件开发中常见的解决方式。


定义：为其他对象提供一种代理以控制(隔离，使用接口)对这对象的访问。


# 行为型设计模式

于定义对象之间的通信与流程控制。


## 迭代器模式

背景：
集合对象内部结构常常变化异常。但对于这些集合对象，我们希望不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种透明遍历也为同一种算法在多种集合对象上进行操作提供了可能。使用面向对象技术将这种遍历机制抽象为”迭代器对象“为”应对变化中的集合对象“提供了一种优雅的方式。


定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露(稳定)该对象的内部表示。


* 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。
* 迭代多态：为遍历不同的集合对象提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
* 对C++来说是过时的，现在迭代器用模板，面向对象的方式性能低




[美团---设计模式二三事](https://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html)